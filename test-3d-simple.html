<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D 模型简单测试</title>
    <style>
        body {
            margin: 0;
            background: #0A0A0A;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            font-family: monospace;
            font-size: 16px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">正在初始化...</div>
    
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { STLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/STLLoader.js';
        
        const info = document.getElementById('info');
        
        try {
            info.textContent = '创建场景...';
            
            // 创建场景
            const scene = new THREE.Scene();
            
            // 创建相机
            const camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 300;
            
            // 创建渲染器
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            info.textContent = '添加光源...';
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xFFD700, 2);
            pointLight.position.set(100, 100, 100);
            scene.add(pointLight);
            
            // 先添加一个测试立方体
            const geometry = new THREE.BoxGeometry(50, 50, 50);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700, 
                wireframe: true 
            });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            info.textContent = '测试立方体已添加，开始加载 STL...';
            
            // 加载 STL 模型
            const loader = new STLLoader();
            let model;
            
            loader.load(
                'output/青铜鼎.stl',
                function(geometry) {
                    info.textContent = 'STL 加载成功！正在处理...';
                    
                    // 移除测试立方体
                    scene.remove(cube);
                    
                    // 居中
                    geometry.center();
                    geometry.computeVertexNormals();
                    
                    // 创建材质
                    const solidMaterial = new THREE.MeshPhongMaterial({
                        color: 0x1a1a1a,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const wireframeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFD700,
                        wireframe: true,
                        opacity: 0.85,
                        transparent: true
                    });
                    
                    // 创建网格
                    const solidMesh = new THREE.Mesh(geometry, solidMaterial);
                    const wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
                    
                    model = new THREE.Group();
                    model.add(solidMesh);
                    model.add(wireframeMesh);
                    
                    // 计算大小并缩放
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 200 / maxDim;
                    model.scale.set(scale, scale, scale);
                    
                    model.rotation.x = -Math.PI / 6;
                    model.rotation.y = Math.PI / 4;
                    
                    scene.add(model);
                    
                    info.textContent = '模型加载完成！尺寸: ' + 
                        size.x.toFixed(1) + ' x ' + 
                        size.y.toFixed(1) + ' x ' + 
                        size.z.toFixed(1);
                },
                function(xhr) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    info.textContent = '加载进度: ' + percent + '%';
                },
                function(error) {
                    info.textContent = '加载失败: ' + error;
                    console.error('错误:', error);
                }
            );
            
            // 动画
            function animate() {
                requestAnimationFrame(animate);
                
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                
                if (model) {
                    model.rotation.y += 0.005;
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // 窗口大小调整
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
        } catch (error) {
            info.textContent = '初始化失败: ' + error.message;
            console.error('错误:', error);
        }
    </script>
</body>
</html>
